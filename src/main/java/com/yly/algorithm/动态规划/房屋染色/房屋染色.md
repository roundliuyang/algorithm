# 房屋染色

## 题目

假如有一排房子，共 `n` 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。

当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 `n x 3` 的正整数矩阵 `costs` 来表示的。

例如，`costs[0][0]` 表示第 0 号房子粉刷成红色的成本花费；`costs[1][2]` 表示第 1 号房子粉刷成绿色的花费，以此类推。

请计算出粉刷完所有房子最少的花费成本。

 

**示例 1：**

```
输入: costs = [[17,2,17],[16,16,5],[14,3,19]]
输出: 10
解释: 将 0 号房子粉刷成蓝色，1 号房子粉刷成绿色，2 号房子粉刷成蓝色。
     最少花费: 2 + 5 + 3 = 10。
```

**示例 2：**

```
输入: costs = [[7,6,2]]
输出: 2
```

 

**提示:**

- `costs.length == n`
- `costs[i].length == 3`
- `1 <= n <= 100`
- `1 <= costs[i][j] <= 20`



## 解题思路



### **状态定义：**

`dp[i][j]` 表示粉刷第 `i` 个房子使用第 `j` 种颜色的最小成本，其中 `j = 0`，`1`，`2` 分别代表三种颜色。

>注意！注意！注意！
>
>dp 数组大小和索引起始点



### 转移方程：

为了计算第 `i` 个房子的最小粉刷成本，必须考虑第 `i-1` 个房子的粉刷颜色，因为不能连续两个房子使用相同的颜色。因此：

- `dp[i][0] = Math.min(dp[i - 1][1], dp[i - 1][2]) + cost[i][0];`
  表示粉刷第 `i` 个房子使用颜色 0 的最小成本，等于粉刷第 `i-1` 个房子时使用颜色 1 或颜色 2 的最小值，加上粉刷当前房子用颜色 0 的成本。

- `dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][2]) + cost[i][1];`
  表示粉刷第 `i` 个房子使用颜色 1 的最小成本，等于粉刷第 `i-1` 个房子时使用颜色 0 或颜色 2 的最小值，加上粉刷当前房子用颜色 1 的成本。

- `dp[i][2] = Math.min(dp[i - 1][0], dp[i - 1][1]) + cost[i][2];`
  表示粉刷第 `i` 个房子使用颜色 2 的最小成本，等于粉刷第 `i-1` 个房子时使用颜色 0 或颜色 1 的最小值，加上粉刷当前房子用颜色 2 的成本。

  

### 初始状态：

`dp[0][0]`、`dp[0][1]`、`dp[0][2]` 分别表示粉刷第 0 个房子使用三种颜色的成本，因此：

- `dp[0][0] = cost[0][0]`
- `dp[0][1] = cost[0][1]`
- `dp[0][2] = cost[0][2]`



### 最终结果：

在所有房子都被粉刷完后，`dp[n-1][0]`、`dp[n-1][1]`、`dp[n-1][2]` 表示粉刷完最后一个房子且使用三种颜色的最小成本。取这三者的最小值，即为粉刷所有房子的最小总成本：

```
return Math.min(dp[n - 1][0], Math.min(dp[n - 1][1], dp[n - 1][2]));
```

## 代码

```java
public int minCost(int[][] cost) {
    int n = cost.length;
    if (n == 0) {
        return 0;
    }
    int[][] dp = new int[n][3];

    dp[0][0] = cost[0][0];
    dp[0][1] = cost[0][1];
    dp[0][2] = cost[0][2];
    for (int i = 1; i < n; i++) {
        dp[i][0] = Math.min(dp[i - 1][1], dp[i - 1][2]) + cost[i][0];
        dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][2]) + cost[i][1];
        dp[i][2] = Math.min(dp[i - 1][1], dp[i - 1][0]) + cost[i][2];
    }
    return Math.min(dp[n - 1][0], Math.min(dp[n - 1][1], dp[n - 1][2]));
}
```

**索引处理**：房子从第 `0` 个房子开始计数，`dp[i][j]` 表示第 `i` 个房子使用颜色 `j` 的最小成本。每次使用 `cost[i][j]` 表示当前房子的粉刷成本。

**初始状态**：第一个房子的粉刷成本直接从 `cost[0][0]`、`cost[0][1]`、`cost[0][2]` 初始化，后面的房子通过递推计算。

**遍历范围**：`i` 从 `1` 到 `n-1`，即从第二个房子开始递推，计算出每个房子选择不同颜色的最小成本。





**或者**

```java
public int minCost(int[][] cost) {
       int n = cost.length;
    if (n == 0) {
        return 0;
    }
    int[][] dp = new int[n+1][3];

    dp[0][0] = 0;
    dp[0][1] = 0;
    dp[0][2] = 0;
    dp[1][0] = cost[0][0];
    dp[1][1] = cost[0][1];
    dp[1][2] = cost[0][2];

    for (int i = 2; i <= n; i++) {
        dp[i][0] = Math.min(dp[i - 1][1], dp[i - 1][2]) + cost[i-1][0];
        dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][2]) + cost[i-1][1];
        dp[i][2] = Math.min(dp[i - 1][1], dp[i - 1][0]) + cost[i-1][2];
    }
    return Math.min(dp[n][0], Math.min(dp[n][1], dp[n][2]));

}
```

**索引处理**：这里的 `dp[i][j]` 表示前 `i` 个房子（从第 1 个房子到第 `i` 个房子）选择颜色 `j` 的最小花费。`cost[i-1][j]` 对应的是第 `i` 个房子，因为 `dp[1]` 对应 `cost[0]`，第一个房子被放在了 `dp[1]`。

**初始状态**：`dp[0][0] = dp[0][1] = dp[0][2] = 0` 表示当没有房子时，粉刷的成本为 0。然后 `dp[1][j]` 对应 `cost[0][j]` 表示第一个房子的粉刷成本。

**遍历范围**：`i` 从 `2` 到 `n`，相当于用 `dp[1]` 表示第一个房子的状态，`dp[i]` 对应第 `i-1` 个房子的成本。



### 主要区别：

1. **dp 数组大小和索引起始点不同**：
   - 第一种解法使用 `n` 行的 `dp` 数组，从 `0` 开始表示第一个房子，因此最后结果是从 `dp[n-1]` 中取得。
   - 第二种解法使用 `n+1` 行的 `dp` 数组，`dp[0]` 是表示没有房子的初始状态，`dp[1]` 表示第一个房子，因此最后结果是从 `dp[n]` 中取得。
2. **初始状态不同**：
   - 第一种解法直接初始化 `dp[0]` 为第一个房子的花费。
   - 第二种解法初始化 `dp[0]` 为 `0`，然后将第一个房子的花费放入 `dp[1]`。
3. **循环范围不同**：
   - 第一种解法的 `i` 从 `1` 到 `n-1`，因为 `dp[0]` 已经表示第一个房子的情况。
   - 第二种解法的 `i` 从 `2` 到 `n`，因为 `dp[1]` 才是第一个房子的情况，`dp[0]` 表示没有房子的情况。

