# 打劫房屋

## 题目

一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组 `nums` ，请计算 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

**示例 1：**

```
输入：nums = [1,2,3,1]
输出：4
解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。
```

**示例 2：**

```
输入：nums = [2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```



## 解题思路

在这个打劫房屋问题中，动态规划的核心是如何在相邻房屋之间进行选择，以获得最大收益。由于不能同时抢劫相邻的房子，因此需要在每一步做出选择：要么抢劫当前房子并跳过前一个房子，要么不抢劫当前房子，而继续之前的最大收益。



### 状态定义：

- `dp[i]` 表示前 `i` 间房子能抢劫到的最大金额。



### 状态转移方程：

- 如果抢劫第 `i` 间房子，那么前 `i-1` 间房子不能被抢劫，收益是 `dp[i-2] + a[i-1]`（`a[i-1]` 是第 `i` 间房子的金额）。
- 如果不抢劫第 `i` 间房子，收益就是前 `i-1` 间房子抢劫的最大金额 `dp[i-1]`。

**因此状态转移方程为：**

```
dp[i] = Math.max(dp[i-1], dp[i-2] + a[i-1])
```



### 解释：

`dp[i-1]` 表示不抢劫第 `i` 间房子时的最大收益。

`dp[i-2] + a[i-1]` 表示抢劫第 `i` 间房子时的最大收益，前提是不能抢劫第 `i-1` 间房子。



### 边界条件：

- `dp[0] = 0`，表示没有房子可以抢劫时的收益为 0。
- `dp[1] = a[0]`，表示只有一间房子时，抢劫该房子的收益就是它的金额。

## 代码

```java
public long houseRobber(int[] a) {
    int n = a.length;
    if (n == 0) {
        return 0;
    }
    long[] dp = new long[n + 1];
    dp[0] = 0;
    dp[1] = a[0];
    for (int i = 2; i <= n; i++) {
        dp[i] = Math.max(dp[i - 1], dp[i - 2] + a[i - 1]);
    }
    return dp[n];
}
```

