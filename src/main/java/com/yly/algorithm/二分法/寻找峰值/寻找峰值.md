# 寻找峰值

## 题目

峰值元素是指其值严格大于左右相邻值的元素。

给你一个整数数组 `nums`，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 **任何一个峰值** 所在位置即可。

你可以假设 `nums[-1] = nums[n] = -∞` 。

你必须实现时间复杂度为 `O(log n)` 的算法来解决此问题。

 

**示例 1：**

```
输入：nums = [1,2,3,1]
输出：2
解释：3 是峰值元素，你的函数应该返回其索引 2。
```

**示例 2：**

```
输入：nums = [1,2,1,3,5,6,4]
输出：1 或 5 
解释：你的函数可以返回索引 1，其峰值元素为 2；
     或者返回索引 5， 其峰值元素为 6。
```

**提示：**

- `1 <= nums.length <= 1000`
- `-231 <= nums[i] <= 231 - 1`
- 对于所有有效的 `i` 都有 `nums[i] != nums[i + 1]`

## 解题思路

这个问题可以用**二分查找**来解决。由于题目要求时间复杂度为 O(log n)，二分法非常适合。



### 思路

1. **寻找峰值的特点**：
   - 如果中间的元素 `nums[mid]` 比两侧的元素都大，那么它就是一个峰值。
   - 如果 `nums[mid]` 小于左侧元素 `nums[mid - 1]`，那么峰值一定在左侧（因为数组边界是负无穷，左侧存在一个更大的数）。
   - 如果 `nums[mid]` 小于右侧元素 `nums[mid + 1]`，那么峰值一定在右侧。
2. **二分法实现**：
   - 通过比较中间元素与相邻元素，逐步缩小搜索范围，直到找到一个峰值。



## 代码

```java
public int findPeakElement(int[] nums) {
    int left = 0;
    int right = nums.length - 1;
    while(left < right){
        int mid  = (left + right )/ 2;
        if(nums[mid] < nums[mid + 1]){
            left = mid + 1;
        }else{
            right = mid;
        }
    }
    return left;
}
```



### 代码解析：

1. **初始化左右指针**：
   - `left` 初始化为 0（数组的第一个元素）。
   - `right` 初始化为 `nums.length - 1`（数组的最后一个元素）。
2. **二分查找过程**：
   - 计算中间位置 `mid = left + (right - left) / 2`，避免 `left + right` 可能产生的整数溢出。
   - **如果 `nums[mid] < nums[mid + 1]`**，说明峰值在右侧，更新 `left = mid + 1`。
   - **否则**，说明峰值在左侧，或者 `mid` 就是峰值，更新 `right = mid`。
3. **终止条件**：
   - 当 `left == right` 时，说明找到了峰值，返回 `left` 或 `right`（此时两者相等）。



### 时间/空间复杂度：

- 每次搜索范围减半，时间复杂度是 O(log n)。

- 由于只用了常数级别的额外空间，空间复杂度是 O(1)。